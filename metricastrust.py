# -*- coding: utf-8 -*-
"""MetricasTrust.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18mvokA2dyRaphsKKsWhyuAlrDZDoG0hr
"""

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc

def preprocess_news_dataset(data):
    
    # Generar columna con la sección principal
    data['seccion_principal'] = data['seccion'].str.split('/').str[0].str.strip()

    # Generar columna con el sentimiento preponderante
    data['sentimiento_preponderante'] = data[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']].idxmax(axis=1)

    # Ajustes de tipos de datos
    data['fecha'] = pd.to_datetime(data['fecha'])
    data['fecha_hora'] = pd.to_datetime(data['fecha_hora'], format='%H:%M:%S').dt.time

    # Generar columnas con ratios útiles
    data['perc_adjectives'] = data['num_adjectives'] / data['num_words'].replace(0, 1)
    data['perc_afirmaciones'] = data['num_afirmaciones'] / data['num_words'].replace(0, 1)
    data['ratio_afirmaciones'] = data['num_afirmaciones_explicitas'] / data['num_afirmaciones'].replace(0, 1)
    data['ratio_referenciados'] = data['num_referenciados'] / data['num_referenciados_unique'].replace(0, 1)
    data['ratio_personas'] = data['num_entidades_persona'] / data['num_entidades'].replace(0, 1)
    data['ratio_organizacion'] = data['num_entidades_organizacion'] / data['num_entidades'].replace(0, 1)
    data['ratio_lugar'] = data['num_entidades_lugar'] / data['num_entidades'].replace(0, 1)
    data['ratio_misc'] = data['num_entidades_misc'] / data['num_entidades'].replace(0, 1)
    data['ratio_conectores'] = data['num_conectores'] / data['num_conectores_unique'].replace(0, 1)

    return data

# Cargar el archivo
file_path = 'dataset_corpus_003.xlsx'
data = pd.read_excel(file_path)

# Preprocesar el dataset
data_preprocessed = preprocess_news_dataset(data)

# Función para definir el sentimiento preponderante
def definir_sentimiento_preponderante(row):
    if row['sentimiento_global_positivo'] >= row['sentimiento_global_neutro'] and row['sentimiento_global_positivo'] >= row['sentimiento_global_negativo']:
        return 'Sentimiento Positivo'
    elif row['sentimiento_global_neutro'] >= row['sentimiento_global_positivo'] and row['sentimiento_global_neutro'] >= row['sentimiento_global_negativo']:
        return 'Sentimiento Neutro'
    else:
        return 'Sentimiento Negativo'

# Función para obtener detalles de las noticias
def obtener_detalles_noticias(data, sentimiento):
    noticias = data[data['sentimiento_preponderante'] == sentimiento]['seccion_principal'].unique()
    noticias = [str(noticia) for noticia in noticias]  # Convertir todos los valores a cadenas de texto
    return '<br>'.join(noticias)

# Función principal para generar las métricas generales y gráficos
def metricas_generales(data):
    # Asegurarse de que las fechas estén en el formato correcto
    data['fecha'] = pd.to_datetime(data['fecha'])

    # Cantidad de noticias analizadas
    cantidad_noticias = len(data)

    # Cantidad de secciones principales
    cantidad_secciones_principales = data['seccion_principal'].nunique()

    # Añadir la columna de sentimiento preponderante
    data['sentimiento_preponderante'] = data.apply(definir_sentimiento_preponderante, axis=1)

    # Calcular la media global de sentimiento positivo, negativo y neutro
    media_sentimientos = data[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']].mean()

    # Sentimiento global a lo largo del tiempo
    sentimiento_tiempo = data.groupby('fecha')[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']].mean().reset_index()

    # Crear line chart de sentimiento a lo largo del tiempo
    fig_line = px.line(sentimiento_tiempo, x='fecha', y=['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo'],
                       title='Sentimiento Global a lo Largo del Tiempo',
                       labels={'value': 'Valor del Sentimiento', 'variable': 'Tipo de Sentimiento'},
                       color_discrete_map={'sentimiento_global_positivo': 'green', 'sentimiento_global_neutro': 'blue', 'sentimiento_global_negativo': 'red'})

    # Calcular la proporción de cada sentimiento preponderante
    proporciones_sentimiento = data['sentimiento_preponderante'].value_counts(normalize=True) * 100

    # Crear un DataFrame para las proporciones de sentimiento
    proporciones_sentimiento_df = proporciones_sentimiento.reset_index()
    proporciones_sentimiento_df.columns = ['Sentimiento', 'Proporción']
    proporciones_sentimiento_df['Detalles'] = proporciones_sentimiento_df['Sentimiento'].apply(lambda x: obtener_detalles_noticias(data, x))

    # Crear el gráfico de pastel (Pie Chart) para las proporciones de sentimiento
    color_map = {'Sentimiento Positivo': 'green', 'Sentimiento Neutro': 'blue', 'Sentimiento Negativo': 'red'}
    fig_pie = px.pie(proporciones_sentimiento_df, values='Proporción', names='Sentimiento',
                     title='Proporción de Noticias con Sentimiento Preponderante',
                     color='Sentimiento', color_discrete_map=color_map)

    # Añadir detalles en el hover para cada porción
    fig_pie.update_traces(
        hoverinfo='label+percent+value+text',
        textinfo='percent',
        insidetextorientation='radial',
        textfont=dict(size=14),
        hovertemplate='<b>%{label}</b><br>Proporción: %{percent}<br>Noticias: %{value}<br>Detalles: %{text}<extra></extra>'
    )

    # Crear un Violin Plot para la distribución de sentimientos del dataset
    sentimientos = data[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']]

    # Renombrar las columnas para mejor legibilidad
    sentimientos = sentimientos.rename(columns={
        'sentimiento_global_positivo': 'Sentimiento Positivo',
        'sentimiento_global_neutro': 'Sentimiento Neutro',
        'sentimiento_global_negativo': 'Sentimiento Negativo'
    })

    # Crear un DataFrame largo para usar con Plotly Express
    sentimientos_long = sentimientos.melt(var_name='Sentimiento', value_name='Valor')

    # Crear el Violin Plot
    fig_violin = px.violin(sentimientos_long, x='Sentimiento', y='Valor', color='Sentimiento', box=True, points='all',
                           title='Distribución de Sentimientos en el Dataset (Violin Plot)',
                           labels={'Valor': 'Valor del Sentimiento', 'Sentimiento': 'Tipo de Sentimiento'},
                           color_discrete_map={'Sentimiento Positivo': 'green', 'Sentimiento Neutro': 'blue', 'Sentimiento Negativo': 'red'})

    # Determinar el sentimiento global preponderante
    sentimiento_global_preponderante = definir_sentimiento_preponderante(media_sentimientos)

    # Resultados
    resultados_m_grales = {
        'cantidad_noticias': cantidad_noticias,
        'cantidad_secciones_principales': cantidad_secciones_principales,
        'media_sentimiento_positivo': media_sentimientos['sentimiento_global_positivo'],
        'media_sentimiento_neutro': media_sentimientos['sentimiento_global_neutro'],
        'media_sentimiento_negativo': media_sentimientos['sentimiento_global_negativo'],
        'sentimiento_preponderante': sentimiento_global_preponderante
    }

    plots_m_grales = {
        'fig_line': fig_line,
        'fig_pie': fig_pie,
        'fig_violin': fig_violin
    }

    return resultados_m_grales, plots_m_grales

# Calcular métricas generales
resultados_m_grales, plots_m_grales = metricas_generales(data_preprocessed)

# Función para definir el sentimiento preponderante
def definir_sentimiento_preponderante(row):
    if row['sentimiento_global_positivo'] >= row['sentimiento_global_neutro'] and row['sentimiento_global_positivo'] >= row['sentimiento_global_negativo']:
        return 'Positivo'
    elif row['sentimiento_global_neutro'] >= row['sentimiento_global_positivo'] and row['sentimiento_global_neutro'] >= row['sentimiento_global_negativo']:
        return 'Neutro'
    else:
        return 'Negativo'

# Función principal para generar las métricas por sección y gráficos por sección
def metricas_por_seccion(seccion_principal, data):
    # Filtrar la data por la seccion principal
    data_seccion_principal = data[data['seccion_principal'] == seccion_principal]

    # Cantidad de noticias analizadas de la seccion principal
    cantidad_noticias_seccion_principal = len(data_seccion_principal)

    # Cantidad de secciones dentro de la seccion principal
    cantidad_secciones = data_seccion_principal['seccion'].nunique()

    # Proporción de noticias con sentimiento positivo, negativo y neutro
    proporcion_sentimientos = data_seccion_principal['sentimiento_preponderante'].value_counts(normalize=True) * 100

    # Medias de sentimiento de la seccion principal
    medias_sentimientos_seccion = data_seccion_principal[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']].mean()

    # Variación porcentual con las medias globales
    medias_globales = data[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']].mean()
    variacion_porcentual = (medias_sentimientos_seccion - medias_globales) / medias_globales * 100

    # Sentimiento preponderante de la seccion principal
    sentimiento_preponderante = definir_sentimiento_preponderante(medias_sentimientos_seccion)

    # Evolución del sentimiento a lo largo del tiempo
    evolucion_sentimiento_tiempo = data_seccion_principal.groupby('fecha')[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']].mean().reset_index()

    # Crear line chart de evolución del sentimiento a lo largo del tiempo
    fig_line = px.line(evolucion_sentimiento_tiempo, x='fecha', y=['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo'],
                       title=f'Evolución del Sentimiento en {seccion_principal} a lo Largo del Tiempo',
                       labels={'value': 'Valor del Sentimiento', 'variable': 'Tipo de Sentimiento'},
                       color_discrete_map={'sentimiento_global_positivo': 'green', 'sentimiento_global_neutro': 'blue', 'sentimiento_global_negativo': 'red'})

    # Crear el gráfico triangular
    sentimiento_secciones = data_seccion_principal.groupby('seccion')[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']].mean()
    sentimiento_secciones['cantidad'] = data_seccion_principal['seccion'].value_counts()
    sentimiento_secciones = sentimiento_secciones.reset_index()

    # Definir el color basado en el sentimiento preponderante
    def definir_color_sentimiento(row):
        sentimiento = definir_sentimiento_preponderante(row)
        if sentimiento == 'Positivo':
            return 'green'
        elif sentimiento == 'Neutro':
            return 'blue'
        else:
            return 'red'

    sentimiento_secciones['color'] = sentimiento_secciones.apply(definir_color_sentimiento, axis=1)

    fig_ternary = px.scatter_ternary(sentimiento_secciones,
                                     a='sentimiento_global_positivo',
                                     b='sentimiento_global_neutro',
                                     c='sentimiento_global_negativo',
                                     size='cantidad',
                                     hover_name='seccion',
                                     color='color',
                                     color_discrete_map={'green': 'green', 'blue': 'blue', 'red': 'red'},
                                     title=f'Sentimiento en Secciones de {seccion_principal}',
                                     size_max=30)

    # Añadir el sentimiento preponderante de la seccion principal al gráfico
    color_principal = definir_color_sentimiento(medias_sentimientos_seccion)
    fig_ternary.add_trace(go.Scatterternary(
        a=[medias_sentimientos_seccion['sentimiento_global_positivo']],
        b=[medias_sentimientos_seccion['sentimiento_global_neutro']],
        c=[medias_sentimientos_seccion['sentimiento_global_negativo']],
        mode='markers+text',
        marker=dict(size=15, color=color_principal, symbol='x'),
        text=[f'{seccion_principal} (Preponderante: {sentimiento_preponderante})'],
        textposition='top center',
        name='Sección Principal'
    ))

    # Ajustar el diseño del gráfico
    fig_ternary.update_layout(
        ternary=dict(
            sum=1,
            aaxis=dict(title='Sentimiento Positivo', min=0.01, linewidth=2, ticks='outside'),
            baxis=dict(title='Sentimiento Neutro', min=0.01, linewidth=2, ticks='outside'),
            caxis=dict(title='Sentimiento Negativo', min=0.01, linewidth=2, ticks='outside')
        ),
        legend_title='Tipo de Sentimiento',
        annotations=[
            dict(
                x=0.5,
                y=-0.2,
                xref='paper',
                yref='paper',
                showarrow=False,
                font=dict(size=12)
            )
        ],
        title={
            'text': f'Sentimiento en Secciones de {seccion_principal}',
            'y':0.9,
            'x':0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        showlegend=True
    )

    # Añadir una leyenda para el sentimiento preponderante
    fig_ternary.add_trace(go.Scatterternary(
        a=[None], b=[None], c=[None],
        mode='markers',
        marker=dict(size=10, color='green', symbol='circle'),
        legendgroup='Positivo', showlegend=True, name='Positivo'
    ))
    fig_ternary.add_trace(go.Scatterternary(
        a=[None], b=[None], c=[None],
        mode='markers',
        marker=dict(size=10, color='blue', symbol='circle'),
        legendgroup='Neutro', showlegend=True, name='Neutro'
    ))
    fig_ternary.add_trace(go.Scatterternary(
        a=[None], b=[None], c=[None],
        mode='markers',
        marker=dict(size=10, color='red', symbol='circle'),
        legendgroup='Negativo', showlegend=True, name='Negativo'
    ))

    # Resultados
    resultados = {
        'cantidad_noticias': cantidad_noticias_seccion_principal,
        'cantidad_secciones': cantidad_secciones,
        'proporcion_sentimientos': proporcion_sentimientos,
        'medias_sentimientos': medias_sentimientos_seccion,
        'variacion_porcentual': variacion_porcentual,
        'sentimiento_preponderante': sentimiento_preponderante
    }

    return resultados, fig_line, fig_ternary

# Filtrar las secciones principales no nulas
secciones_principales = data_preprocessed['seccion_principal'].dropna().unique()

# Función para definir el sentimiento preponderante
def definir_sentimiento_preponderante(row):
    if row['sentimiento_global_positivo'] >= row['sentimiento_global_neutro'] and row['sentimiento_global_positivo'] >= row['sentimiento_global_negativo']:
        return 'Positivo'
    elif row['sentimiento_global_neutro'] >= row['sentimiento_global_positivo'] and row['sentimiento_global_neutro'] >= row['sentimiento_global_negativo']:
        return 'Neutro'
    else:
        return 'Negativo'

# Función para normalizar los sentimientos por autor y sección principal
def normalizar_sentimientos(df):
    df_sum = df.sum(axis=1)
    df_normalizado = df.div(df_sum, axis=0)
    return df_normalizado

# Función principal para generar las métricas y gráficos por autor
def metricas_por_autor(seccion_principal, data):
    # Filtrar la data por la seccion principal
    data_seccion_principal = data[data['seccion_principal'] == seccion_principal]

    # Agrupar los datos por autor y sección principal
    sentimientos_por_autor_seccion_principal = data_seccion_principal.groupby(['seccion_principal', 'autor'])[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']].sum().reset_index()

    # Normalizar los sentimientos para que sumen 1 por cada autor y sección principal
    sentimientos_por_autor_seccion_principal[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']] = normalizar_sentimientos(sentimientos_por_autor_seccion_principal[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']])

    # Crear gráficos de barras apiladas para cada sección principal
    fig_barras = px.bar(sentimientos_por_autor_seccion_principal, x='autor', y=['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo'],
                        title=f'Proporción de Sentimientos por Autor en {seccion_principal}',
                        labels={'value': 'Proporción del Sentimiento', 'autor': 'Autor'},
                        color_discrete_map={'sentimiento_global_positivo': 'green', 'sentimiento_global_neutro': 'blue', 'sentimiento_global_negativo': 'red'},
                        barmode='stack')

    # Ajustar el diseño del gráfico
    fig_barras.update_layout(
        xaxis_title='Autor',
        yaxis_title='Proporción del Sentimiento',
        legend_title='Tipo de Sentimiento',
        title={
            'text': f'Proporción de Sentimientos por Autor en {seccion_principal}',
            'y':0.9,
            'x':0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        showlegend=True
    )

    # Calcular el sentimiento preponderante
    media_sentimientos = data_seccion_principal[['sentimiento_global_positivo', 'sentimiento_global_neutro', 'sentimiento_global_negativo']].mean()
    sentimiento_preponderante = definir_sentimiento_preponderante(media_sentimientos)

    resultados = {
        'sentimiento_preponderante': sentimiento_preponderante
    }

    return resultados, fig_barras

import dash
from dash import dcc, html
from dash.dependencies import Input, Output
import dash_bootstrap_components as dbc

# Suponiendo que `data_preprocessed['seccion_principal']` es la lista de secciones
secciones_principales = data_preprocessed['seccion_principal'].dropna().unique()

# Crear la aplicación Dash con suppress_callback_exceptions habilitado
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], suppress_callback_exceptions=True)

server = app.server

# Definir el layout de la aplicación
app.layout = dbc.Container([
    dcc.Tabs(id="tabs-example", value='tab-1', children=[
        dcc.Tab(label='Generales', value='tab-1'),
        dcc.Tab(label='Por Sección', value='tab-2'),
        dcc.Tab(label='Por Autor', value='tab-3'),
    ]),
    html.Div(id='tabs-content')
])

# Callback para renderizar el contenido de cada solapa
@app.callback(Output('tabs-content', 'children'),
              [Input('tabs-example', 'value')])
def render_content(tab):
    if tab == 'tab-1':
        return dbc.Container([
            dbc.Row([
                dbc.Col(dbc.Card([
                    dbc.CardBody([
                        html.H2('Resultados', className='card-title', style={'textAlign': 'center'}),
                        html.H1(f'{resultados_m_grales["cantidad_noticias"]}', className='card-text', style={'textAlign': 'center'}),
                        html.P('Noticias Analizadas', className='card-text', style={'textAlign': 'center'}),
                        html.H1(f'{resultados_m_grales["cantidad_secciones_principales"]}', className='card-text', style={'textAlign': 'center'}),
                        html.P('Secciones Principales', className='card-text', style={'textAlign': 'center'}),
                        html.H2(f'{resultados_m_grales["sentimiento_preponderante"]}', className='card-title', style={'textAlign': 'center', 'color': 'blue'}),
                        html.P('Sentimiento Preponderante', className='card-text', style={'textAlign': 'center'})
                    ])
                ], style={'margin-bottom': '20px'}), width=3),
                dbc.Col(dcc.Graph(figure=plots_m_grales['fig_line']), width=9)
            ], className='mb-4'),
            dbc.Row([
                dbc.Col(dcc.Graph(figure=plots_m_grales['fig_violin']), width=10),
                dbc.Col(dbc.Card([
                    dbc.CardBody([
                        html.H3(f'{resultados_m_grales["media_sentimiento_positivo"]:.3f}', className='card-title', style={'color': 'green', 'textAlign': 'center'}),
                        html.P('Media Sentimiento Positivo', className='card-text', style={'textAlign': 'center'}),
                        html.H3(f'{resultados_m_grales["media_sentimiento_neutro"]:.3f}', className='card-title', style={'color': 'blue', 'textAlign': 'center'}),
                        html.P('Media Sentimiento Neutro', className='card-text', style={'textAlign': 'center'}),
                        html.H3(f'{resultados_m_grales["media_sentimiento_negativo"]:.3f}', className='card-title', style={'color': 'red', 'textAlign': 'center'}),
                        html.P('Media Sentimiento Negativo', className='card-text', style={'textAlign': 'center'})
                    ])
                ], style={'margin-bottom': '20px'}), width=2)
            ], className='mb-4'),
        ], fluid=True)

    elif tab == 'tab-2':
        return dbc.Container([
            dbc.Row([
                dbc.Col(html.Div([
                    html.Label('Seleccione la Sección Principal'),
                    dcc.Dropdown(
                        id='seccion-dropdown',
                        options=[{'label': seccion, 'value': seccion} for seccion in secciones_principales if seccion],
                        value=secciones_principales[0]
                    )
                ]), width=12)
            ], className='mb-4'),
            dbc.Row([
                dbc.Col(dbc.Card([
                    dbc.CardBody([
                        html.H2('Resultados', className='card-title', style={'textAlign': 'center'}),
                        html.H1(id='cantidad-noticias', className='card-text', style={'textAlign': 'center'}),
                        html.P('Noticias Analizadas', className='card-text', style={'textAlign': 'center'}),
                        html.H1(id='cantidad-secciones', className='card-text', style={'textAlign': 'center'}),
                        html.P('Subsecciones', className='card-text', style={'textAlign': 'center'}),
                        html.H2(id='sentimiento-preponderante', className='card-title', style={'textAlign': 'center'}),
                        html.P('Sentimiento Preponderante', className='card-text', style={'textAlign': 'center'})
                    ])
                ], style={'margin-bottom': '20px'}), width=3),
                dbc.Col(dcc.Graph(id='fig-line'), width=9)
            ], className='mb-4'),
            dbc.Row([
                dbc.Col(dcc.Graph(id='fig-ternary'), width=9),
                dbc.Col(dbc.Card([
                    dbc.CardBody([
                        html.H3(id='media-sentimiento-positivo', className='card-title', style={'color': 'green', 'textAlign': 'center'}),
                        html.P('Media Sentimiento Positivo | Variación sobre Global', className='card-text', style={'textAlign': 'center'}),
                        html.H3(id='media-sentimiento-neutro', className='card-title', style={'color': 'blue', 'textAlign': 'center'}),
                        html.P('Media Sentimiento Neutro | Variación sobre Global', className='card-text', style={'textAlign': 'center'}),
                        html.H3(id='media-sentimiento-negativo', className='card-title', style={'color': 'red', 'textAlign': 'center'}),
                        html.P('Media Sentimiento Negativo | Variación sobre Global', className='card-text', style={'textAlign': 'center'}),
                    ])
                ], style={'margin-bottom': '20px'}), width=3)
            ])
        ], fluid=True)

    elif tab == 'tab-3':
        return dbc.Container([
            dbc.Row([
                dbc.Col(html.Div([
                    html.Label('Seleccione la Sección Principal'),
                    dcc.Dropdown(
                        id='seccion-dropdown-autor',
                        options=[{'label': seccion, 'value': seccion} for seccion in secciones_principales if seccion],
                        value=secciones_principales[0]
                    )
                ]), width=6)
            ], className='mb-4'),
            dbc.Row([
                dbc.Col(dcc.Graph(id='fig-barras'), width=10),
                dbc.Col(dbc.Card([
                    dbc.CardBody([
                        html.H2(id='sentimiento-preponderante-autor', className='card-title', style={'textAlign': 'center'}),
                        html.P('Sentimiento Preponderante', className='card-text', style={'textAlign': 'center'})
                    ])
                ]), width=2)
            ])
        ], fluid=True)

# Callback para actualizar las métricas en 'Por Sección'
@app.callback(
    [Output('cantidad-noticias', 'children'),
     Output('cantidad-secciones', 'children'),
     Output('sentimiento-preponderante', 'children'),
     Output('fig-line', 'figure'),
     Output('fig-ternary', 'figure'),
     Output('media-sentimiento-positivo', 'children'),
     Output('media-sentimiento-neutro', 'children'),
     Output('media-sentimiento-negativo', 'children')],
    [Input('seccion-dropdown', 'value')]
)
def actualizar_metricas_por_seccion(seccion_principal):
    resultados, fig_line, fig_ternary = metricas_por_seccion(seccion_principal, data_preprocessed)
    return (resultados['cantidad_noticias'],
            resultados['cantidad_secciones'],
            resultados['sentimiento_preponderante'],
            fig_line,
            fig_ternary,
            f'{resultados["medias_sentimientos"]["sentimiento_global_positivo"]:.3f} | {resultados["variacion_porcentual"]["sentimiento_global_positivo"]:.2f}%',
            f'{resultados["medias_sentimientos"]["sentimiento_global_neutro"]:.3f} | {resultados["variacion_porcentual"]["sentimiento_global_neutro"]:.2f}% ',
            f'{resultados["medias_sentimientos"]["sentimiento_global_negativo"]:.3f} | {resultados["variacion_porcentual"]["sentimiento_global_negativo"]:.2f}%')

# Callback para actualizar las métricas en 'Por Autor'
@app.callback(
    [Output('fig-barras', 'figure'),
     Output('sentimiento-preponderante-autor', 'children')],
    [Input('seccion-dropdown-autor', 'value')]
)
def actualizar_metricas_por_autor(seccion_principal):
    resultados, fig_barras = metricas_por_autor(seccion_principal, data_preprocessed)
    sentimiento_preponderante = resultados['sentimiento_preponderante']
    return fig_barras, sentimiento_preponderante

# Ejecutar la aplicación
if __name__ == '__main__':
    app.run_server(debug=True)
